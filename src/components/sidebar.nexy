---
from "./data.py" import menu
---
<nav class="w-64 bg-slate-950 min-h-screen shadow-lg">
    <div class="p-6">
        <h2 class="text-xl font-bold text-white mb-8">Menu</h2>
    </div>
    <ul class="space-y-2 px-3">
        {% for i in menu %}
        <li>
           <a href="{{ i.get('href') }}" 
            class="flex items-center px-4 py-3 text-slate-200 rounded-md transition-colors hover:bg-slate-800 hover:text-white font-medium"
            nexy-prefetch
            >
                {{ i.get("label") }}
            </a>
        </li>
        {% endfor %}
    </ul>
</nav><script>
    // Utilisation d'un objet Map (plus performant pour le cache que {})
    const PageCache = new Map();

    // 1. Fonction de Fetch optimisée
    async function fetchPage(url) {
        if (PageCache.has(url)) return PageCache.get(url);
        
        try {
            // Priorité basse pour ne pas bloquer les autres ressources importantes
            const response = await fetch(url, { priority: 'low' });
            if (!response.ok) throw new Error('Network response was not ok.');
            
            const html = await response.text();
            PageCache.set(url, html);
            
            return html;
        } catch (error) {
            console.error('Erreur prefetch:', error);
            return null; // En cas d'erreur
        }
    }

    // 2. Fonction de Navigation (Le cœur de la magie)
    async function navigateTo(url, isPopState = false) {
        let html = PageCache.get(url);
        
        // Si la page n'est pas encore en cache au moment du clic, on la fetch
        if (!html) {
            html = await fetchPage(url);
        }
        
        if (html) {
            // On utilise DOMParser pour extraire proprement le contenu sans casser la page
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            
            // On met à jour le titre de l'onglet et le contenu du body
            document.title = doc.title;
            document.body.innerHTML = doc.body.innerHTML;
            
            // On met à jour l'URL dans la barre d'adresse (sauf si on utilise le bouton "Retour")
            if (!isPopState) {
                history.pushState({ url: url }, '', url);
            }
            
            // On relance l'observateur pour les liens de la NOUVELLE page
            initPrefetch(); 
        } else {
            // Fallback de sécurité : si le fetch échoue, on fait une navigation normale
            window.location.href = url;
        }
    }

    // 3. Initialisation du préchargement intelligent (Intersection Observer)
    let observer;
    function initPrefetch() {
        if (observer) observer.disconnect(); // Nettoie l'ancien observateur
        
        observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    fetchPage(entry.target.href);
                    observer.unobserve(entry.target); // Stop l'observation une fois fetché
                }
            });
        }, { rootMargin: '50px' }); // Commence à fetcher 50px avant que le lien soit visible

        document.querySelectorAll('a[nexy-prefetch]').forEach(link => {
            observer.observe(link);
        });
    }

    // 4. Écouteur global pour les clics (Délégation d'événements)
    document.addEventListener('click', function(event) {
        // Cherche si on a cliqué sur un lien avec notre attribut
        const link = event.target.closest('a[nexy-prefetch]');
        
        if (link && link.href.startsWith(window.location.origin)) {
            event.preventDefault();
            navigateTo(link.href);
        }
        console.clear("")
    });

    // 5. Gérer le bouton "Retour" et "Suivant" du navigateur
    window.addEventListener('popstate', function(event) {
        if (event.state && event.state.url) {
            navigateTo(event.state.url, true);
        } else {
            window.location.reload(); // Fallback
        }
    });

    // Lancement au démarrage de la page
    document.addEventListener('DOMContentLoaded', () => {
        // Enregistre la page actuelle dans l'historique initial
        history.replaceState({ url: window.location.href }, '', window.location.href);
        initPrefetch();
    });
</script>